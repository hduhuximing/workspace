## 标签:深度优先搜索题目（并非全都用该算法解决）

​		它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。

![image-20191210165355399](/Users/huximing/IdeaProjects/ziliao/workspace/Math/深度优先搜索.assets/image-20191210165355399.png)

**从V0开始遍历，**

- V0->V1->V4，此时到底尽头，仍然到不了V6，于是原路返回到V1去搜索其他路径；

- 返回到V1后既搜索V2，于是搜索路径是V0->V1->V2->V6,，找到目标节点，返回有解。

**DFS适合此类题目**：给定初始状态跟目标状态，要求判断从初始状态到目标状态是否有解。

### 题目

#### Leetcode98[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree)  

**题目：**

```java
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
  假设一个二叉搜索树具有如下特征：
  节点的左子树只包含小于当前节点的数。
  节点的右子树只包含大于当前节点的数。
  所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

```

思路：

- ​	此题用递归更简单，这里定义一个最大值和一个最小值，作为每个节点的比较，通过每次更新最大最小值实现二叉树的验证。

代码：

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return valid(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
    public boolean valid(TreeNode root,Long min,Long max){
        if(root==null){
            return true;
        }
        if(root.val<=min||root.val>=max){
            return false;
        }
        return valid(root.left,min,(long)root.val)&&valid(root.right,(long)root.val,max);
    }
}
```

时间复杂度o(n)

空间复杂度o(n)

#### Leetcode99[ 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree)  

**题目：**

```java
二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

示例 1:

输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
示例 2:

输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3

```

代码：

```java
 //二叉搜索树，中序遍历是递增序列，找到序列中前一个数据比后一个大的位置，为出错的点
 //声明first（第一个出错），second（第二个出错），以及prev（存储当前遍历前一个值）
class Solution {
    TreeNode first=null;
    TreeNode second=null;
    TreeNode prev=null;
    public void recoverTree(TreeNode root) {
        if(root==null){
            return ;
        }
        help(root);
        int temp=first.val;
        first.val=second.val;
        second.val=temp;
    }
    //中序遍历思想
    public void help(TreeNode root){
        //返回条件空值
        if(root==null){
            return ;
        }
        help(root.left);
        //判断条件，是否错误,题目中说明只有两个节点错误，help方法帮助找到first和second节点
        //中序遍历顺序输出
        //考虑first和second的取值在中序遍历中是相邻还是不相邻，如果就是相邻的，first=prev second =root
        //不相邻，此时只要进入此方法先更新second，此时不是最终值，后面肯定还有一次进入if语句的机会，
        //而第一次进入的时候已经将找到first出错的位置，因此要加入判断，
        if(prev!=null&&prev.val>=root.val){
            if(first==null){
                first=prev;
            }
            second=root;
        }
        prev=root;
        help(root.right);
    }
}
```

#### leetcode100[相同的树](https://leetcode-cn.com/problems/same-tree)  

题目：

```java
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

代码：

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        //都是空直接返回true
        //去除都是空，其中一个是空返回false
        //都不是空，值不相等返回false；
        //递归调用，直到走到空返回true
        if(p==null&&q==null){
            return true;
        }
        if(p==null||q==null){
            return false;
        }
        if(p.val!=q.val){
            return false;
        }
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```

#### leetcode101[ 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)  

题目：

```java
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3

```

代码:

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isValid(root,root);    
    }
    //借助辅助方法，首先传入两个节点，
    //如果都是空返回true，只要有一个非空，返回false
    //最终条件，传入的两个节点值相等，向下找，第一个节点的左边，第二个节点的右侧，和第一个节点的右侧，第二个节点的左边
    public boolean isValid(TreeNode root1,TreeNode root2){
        if(root1==null&&root2==null){
            return true;
        }
        if(root1==null||root2==null){
            return false;
        }
        if(root1.val!=root2.val){
            return false;
        }
        return isValid(root1.left,root2.right)&&isValid(root1.right,root2.left);
    }
}
```

#### leetcode104[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

题目:

```java
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

```

代码：

```java
class Solution {
    public int maxDepth(TreeNode root) { 
        //递归获取左右节点深度，每次遍历返回结果+1。
        // 跳出条件，遍历到null。
        if (root == null)
            return 0;
        int leftDeep=maxDepth(root.left);
        int rightDeep=maxDepth(root.right);
        return Math.max(leftDeep,rightDeep)+1;
    }
}
```

#### leetcode105 [ 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)  

```java
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

代码：

```java
class Solution {
    //前序遍历的值是数据的根节点，通过前序遍历的根节点将中序遍历分割为，左右两边，循环调用直到前序遍历结束，或者分割后的start>end
     public TreeNode buildTree(int[] preorder, int[] inorder) {
        int inLen=inorder.length;
        int preLen=preorder.length;
        //对传入的数组进行检测
        if(inLen!=preLen){
            return null;
        }else if(inLen==0){
            return null;
        }else if(inLen==1){
            return new TreeNode(inorder[0]);
        }
        return helper(preorder,0,inorder,0,inLen-1);
    }
    
    public TreeNode helper(int[]preorder,int index,int[] inorder,int start,int end){
        if(index>=preorder.length||start>end){
            return null;
        }
        //获取当前遍历到的根节点
        int curr=preorder[index];
        //循环查找相等的位置，找到后设置TreeNode，并遍历得到左边和右边，要求，取出遍历到的点，从i-1或者i+1位置开始找。
        for(int i=start;i<=end;i++){
            if(inorder[i]==curr){
                TreeNode root=new TreeNode(curr);
                root.left=helper(preorder,++index,inorder,start,i-1);
                root.right=helper(preorder,++index,inorder,i+1,end);
                return root;
            }
        }
        return null;
    }   
}
```

#### leetcode106[ 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)  

题目:

```java
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

代码：

```java
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int inLen=inorder.length;
        int postLen=postorder.length;
        //对传入的数组进行检测
        if(inLen!=postLen){
            return null;
        }
        if(inLen==0){
            return null;
        }
        if(inLen==1){
            return new TreeNode(inorder[0]);
        }
        index=inLen-1;
        return helper(inorder, postorder, 0, inLen - 1);        
    }
    //和上一道题的区别就在于从后往前找，后序遍历的最后一个值是当前的根节点。
    public TreeNode helper(int [] inorder,int []postorder,int start,int end){
        if(start>end){
            return null;
        }
        //查询出后续遍历的最后一个，即为根节点 
        int val=postorder[index--];
        for(int i=start;i<=end;i++){
            if(inorder[i]==val){
                TreeNode root=new TreeNode(val);
                root.right=helper(inorder,postorder,i+1,end);
                root.left=helper(inorder,postorder,start,i-1);
                return root;
            }
        }
        return null;
    }
}
```

#### leetcode108[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)  

题目：

```java
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
//二分就完事了，要求节点高度不能超过1，二分不可能超过1
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // return sortArray(nums,0,nums.length-1);
        return sort1(nums,0,nums.length-1);
    }

   
    //二分查找，中间值作为根节点，左右两边分开 ，当左边等于右边的时候结束，此时表示其仅有一个节点，不用分割
    public TreeNode sortArray(int[] nums,int left,int right){
        //跳出条件
        if(left>right){
            return null;
        }
        int mid=(left+right)/2;
        TreeNode root=new TreeNode(nums[mid]);
        root.left=sortArray(nums,left,mid-1);
        root.right=sortArray(nums,mid+1,right);
        return root;
    }
}
```

#### leetcode109[ 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)  

```java
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

代码：

```java
 //题目要求左右结点高度不能相差超过1，用二分法，每次两边的结点树必然不大于1.
 //与上一道题不同的是，找中点，用快慢指针。
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
      	//此处传入头尾节点
        return helper(head, null);
    }
    //找中间值，进行递归，每次记录开始和结束位置，
    //结束位置tail每次都是不可达的位置，第一次为null。后面如果是左侧为当前slow，如果是右节点为tail。
    //左侧是slow的原因是，当前slow已经遍历过了，作为根节点。
    private TreeNode helper(ListNode head, ListNode tail) {
        //头尾相同直接返回null
        if (head == tail) return null;
        // mid
        ListNode slow = head;
        ListNode fast = head;
        while (fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }
        TreeNode root = new TreeNode(slow.val);
        root.left = helper(head, slow);
        root.right = helper(slow.next, tail);
        return root;
    }
}
```

#### leetcode110[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree) 

```java
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

代码：

```java
class Solution {
  	//设置标志位
    boolean res=true;
    public boolean isBalanced(TreeNode root) {
        valid(root);
        return res;
    }
  	//与求最大深度一样循环遍历，找到当前左右的能到达的最大深度，
    //比较左右最大深度是否大于1,更新标志位.
    public int valid(TreeNode root){
        //空则返回0.  
        if(root==null)
            return 0;
        int left=valid(root.left)+1;
        int right=valid(root.right)+1;
        if(Math.abs(left-right)>1){
            res=false;
        }
        //返回该节点的高度，即为最大值
        return Math.max(left,right);
    }
}
```

#### Leetcode111[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```java
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

代码：

```java
class Solution {
  //因为是要求最小深度，每次循环应该用新的值判断，先去除根为null和左右节点都为空的情况，
  //分开单独判断左右两边节点，非空才读取并和min进行比较。最终返回min+1。
  public int minDepth(TreeNode root) {
			if(root==null){
        return 0;
      }
      int min=Integer.MAX_VALUE;
      if(root.left==null&&root.right==null){
        return 1;
      }
      if(root.left!=null){
            int left=minDepth(root.left);
            min=Math.min(left,min);
        }
      if(root.right!=null){
            int right=minDepth(root.right);
            min=Math.min(right,min);
        }
        return min+1;
    }
}
```

